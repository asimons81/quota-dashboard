<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Quota Mission Control</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;800&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg-deep: #050506;
      --bg-panel: #0f1012;
      --border-metal: #1a2a26;
      --text-main: #e0e0e0;
      --text-dim: #7a7f84;
      --ok: #4fb7a0;
      --warn: #ffb700;
      --bad: #ff3e3e;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at 50% 10%, #10201c 0%, #050506 55%);
      color: var(--text-main);
      font-family: Outfit, sans-serif;
    }
    header {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: space-between;
      align-items: center;
      padding: 18px 24px;
      border-bottom: 1px solid var(--border-metal);
      background: rgba(10, 13, 14, 0.92);
    }
    .title { font-size: 1.15rem; font-weight: 800; letter-spacing: 2px; text-transform: uppercase; }
    .controls { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    button {
      border: none;
      border-radius: 8px;
      padding: 9px 14px;
      font-weight: 700;
      background: var(--ok);
      color: #04261f;
      cursor: pointer;
    }
    button[disabled] { opacity: .6; cursor: progress; }
    .pill {
      border: 1px solid var(--border-metal);
      background: rgba(0,0,0,.25);
      border-radius: 999px;
      padding: 7px 12px;
      font-size: .75rem;
      font-family: "JetBrains Mono", monospace;
    }
    .status-ok { color: var(--ok); }
    .status-stale { color: var(--warn); }
    .status-error { color: var(--bad); }
    #banner {
      display: none;
      margin: 12px 24px 0;
      border: 1px solid rgba(255,62,62,.4);
      border-radius: 8px;
      padding: 10px 12px;
      color: #ffd5d5;
      background: rgba(255,62,62,.14);
      font-size: .9rem;
    }
    #error-panel {
      margin: 12px 24px;
      border: 1px solid var(--border-metal);
      border-radius: 10px;
      background: rgba(8,10,11,.75);
      padding: 14px;
      font-size: .9rem;
      line-height: 1.4;
    }
    #error-panel h2 { margin: 0 0 8px; font-size: 1rem; }
    #error-panel ul { margin: 8px 0 0 18px; color: var(--text-dim); }
    main {
      padding: 24px;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 16px;
    }
    .card {
      border: 1px solid var(--border-metal);
      border-radius: 12px;
      background: var(--bg-panel);
      padding: 16px;
    }
    .top { display: flex; justify-content: space-between; gap: 10px; }
    .provider { font-size: .8rem; color: var(--text-dim); text-transform: uppercase; letter-spacing: 1px; }
    .label { font-size: 1.1rem; font-weight: 700; margin-top: 3px; }
    .percent { font-family: "JetBrains Mono", monospace; font-size: 1.1rem; font-weight: 700; }
    .bar { height: 10px; border-radius: 999px; overflow: hidden; background: #1a1c1f; margin: 12px 0; }
    .fill { height: 100%; }
    .meta { display: grid; gap: 6px; font-size: .82rem; color: var(--text-dim); }
    .sparkline { width: 60px; height: 18px; }
    .empty {
      margin: 24px;
      border: 1px dashed var(--border-metal);
      padding: 24px;
      border-radius: 12px;
      text-align: center;
      color: var(--text-dim);
    }
  </style>
</head>
<body>
  <header>
    <div class="title">Quota Core</div>
    <div class="controls">
      <button id="sync-button" type="button">SYNC NOW</button>
      <div class="pill">Status: <span id="status-text" class="status-stale">STALE</span></div>
      <div class="pill" id="last-sync">Last good data: --</div>
    </div>
  </header>

  <div id="banner"></div>

  <section id="error-panel">
    <h2>Data Health</h2>
    <div>Last fetch error: <span id="last-error">None</span></div>
    <div>Last good data time: <span id="last-good-time">--</span></div>
    <ul>
      <li>Usage can jump or drop at reset boundaries.</li>
      <li>If status is STALE/ERROR, verify scanner scheduling and OpenClaw credentials.</li>
      <li>Cross-origin sync endpoints may fail due to CORS; configure same-origin proxy when possible.</li>
    </ul>
  </section>

  <main id="dashboard-grid"></main>

  <script>
    const REFRESH_MS = 30000;
    const STALE_MS = 120000;
    const cacheKey = 'quota_cache_v2';

    let dashboardData = null;
    let historyData = {};
    let config = { syncEndpoint: null, syncMethod: 'POST', syncPayload: {}, refreshDelayMs: 3000 };
    let lastFetchSuccessAt = 0;
    let lastFetchError = null;

    const grid = document.getElementById('dashboard-grid');
    const syncButton = document.getElementById('sync-button');
    const statusText = document.getElementById('status-text');
    const lastSyncText = document.getElementById('last-sync');
    const lastErrorText = document.getElementById('last-error');
    const lastGoodTimeText = document.getElementById('last-good-time');
    const banner = document.getElementById('banner');

    const showBanner = (message) => {
      banner.textContent = message;
      banner.style.display = 'block';
      clearTimeout(showBanner._timer);
      showBanner._timer = setTimeout(() => banner.style.display = 'none', 7000);
    };

    const localDate = (iso) => {
      const date = new Date(iso);
      if (isNaN(date.getTime())) return '--';
      return date.toLocaleString();
    };

    function classifyColor(percent) {
      if (percent < 50) return 'var(--ok)';
      if (percent < 80) return 'var(--warn)';
      return 'var(--bad)';
    }

    function formatCountdown(resetAt) {
      if (!resetAt) return 'No reset timestamp';
      const diff = Number(resetAt) - Date.now();
      if (diff <= 0) return 'Reset window reached';
      const h = Math.floor(diff / 3600000);
      const m = Math.floor((diff % 3600000) / 60000);
      const s = Math.floor((diff % 60000) / 1000);
      return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
    }

    function renderSparkline(series) {
      const points = (series || []).slice(-20);
      if (!points.length) {
        return '<svg class="sparkline" viewBox="0 0 60 18" aria-label="No trend"><line x1="0" y1="17" x2="60" y2="17" stroke="#444"/></svg>';
      }
      const coords = points.map((item, i) => {
        const x = points.length === 1 ? 0 : (i / (points.length - 1)) * 60;
        const y = 18 - (Math.max(0, Math.min(100, Number(item.percentage) || 0)) / 100) * 18;
        return `${x.toFixed(1)},${y.toFixed(1)}`;
      }).join(' ');
      return `<svg class="sparkline" viewBox="0 0 60 18" aria-label="Trend"><polyline fill="none" stroke="var(--ok)" stroke-width="1.6" points="${coords}"/></svg>`;
    }

    function updateStatus() {
      const now = Date.now();
      let status = 'OK';
      let cls = 'status-ok';

      if (!dashboardData && !localStorage.getItem(cacheKey)) {
        status = 'ERROR';
        cls = 'status-error';
      } else {
        const sourceTs = dashboardData?.lastUpdated ? Date.parse(dashboardData.lastUpdated) : NaN;
        const ageFromSource = Number.isFinite(sourceTs) ? now - sourceTs : Infinity;
        const ageFromFetch = lastFetchSuccessAt ? now - lastFetchSuccessAt : Infinity;
        if (ageFromSource > STALE_MS || ageFromFetch > STALE_MS) {
          status = 'STALE';
          cls = 'status-stale';
        }
      }

      statusText.textContent = status;
      statusText.className = cls;

      const goodTime = dashboardData?.lastUpdated || (lastFetchSuccessAt ? new Date(lastFetchSuccessAt).toISOString() : null);
      const local = goodTime ? localDate(goodTime) : '--';
      lastSyncText.textContent = `Last good data: ${local}`;
      lastSyncText.title = goodTime || '';
      lastGoodTimeText.textContent = local;
      lastGoodTimeText.title = goodTime || '';
      lastErrorText.textContent = lastFetchError || 'None';
    }

    function renderModels() {
      const models = dashboardData?.models || [];
      if (!models.length) {
        grid.innerHTML = '<div class="empty">No usage windows found (check credentials).</div>';
        return;
      }

      grid.innerHTML = models.map((model) => {
        const pct = Math.max(0, Math.min(100, Number(model.percentage) || 0));
        const color = classifyColor(pct);
        const trend = renderSparkline(historyData[model.key]);
        const resetIso = model.resetAtIso || (model.resetAt ? new Date(model.resetAt).toISOString() : '');
        return `
          <article class="card">
            <div class="top">
              <div>
                <div class="provider">${model.provider || 'Unknown provider'}</div>
                <div class="label">${model.label || model.key}</div>
              </div>
              <div class="percent" style="color:${color}">${pct.toFixed(2)}%</div>
            </div>
            <div class="bar"><div class="fill" style="width:${pct}%;background:${color}"></div></div>
            <div class="meta">
              <div>Reset in: <span class="countdown" data-reset="${model.resetAt || ''}">${formatCountdown(model.resetAt)}</span></div>
              <div title="${resetIso || ''}">Reset at: ${resetIso ? localDate(resetIso) : '--'}</div>
              <div>Key: ${model.key}</div>
              <div>Trend: ${trend}</div>
            </div>
          </article>
        `;
      }).join('');
    }

    async function fetchConfig() {
      try {
        const res = await fetch('config.json', { cache: 'no-store' });
        if (!res.ok) return;
        config = { ...config, ...(await res.json()) };
      } catch (_) {
        // optional config fallback
      }
      syncButton.textContent = config.syncEndpoint ? 'SYNC NOW' : 'REFRESH';
    }

    async function fetchHistory() {
      try {
        const v = Math.floor(Date.now() / 30000);
        const res = await fetch(`history.json?v=${v}`, { cache: 'no-store' });
        if (!res.ok) return;
        historyData = await res.json();
      } catch (_) {
        historyData = {};
      }
    }

    async function fetchData() {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000);
      try {
        const v = Math.floor(Date.now() / 30000);
        const res = await fetch(`data.json?v=${v}`, { cache: 'no-store', signal: controller.signal });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const text = await res.text();
        dashboardData = JSON.parse(text);
        localStorage.setItem(cacheKey, text);
        lastFetchSuccessAt = Date.now();
        lastFetchError = null;
      } catch (error) {
        lastFetchError = error.message || String(error);
        const cached = localStorage.getItem(cacheKey);
        if (cached) {
          dashboardData = JSON.parse(cached);
          showBanner(`Using cached data. Latest fetch failed: ${lastFetchError}`);
        } else {
          dashboardData = null;
          showBanner(`Unable to load data.json: ${lastFetchError}`);
        }
      } finally {
        clearTimeout(timeoutId);
      }
      renderModels();
      updateStatus();
    }

    async function triggerSync() {
      syncButton.disabled = true;
      try {
        if (!config.syncEndpoint) {
          await fetchData();
          return;
        }

        const response = await fetch(config.syncEndpoint, {
          method: config.syncMethod || 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(config.syncPayload || {})
        });

        if (!response.ok) {
          throw new Error(`Sync endpoint returned HTTP ${response.status}`);
        }

        setTimeout(fetchData, Number(config.refreshDelayMs) || 3000);
      } catch (error) {
        const msg = error instanceof TypeError
          ? 'Sync failed: network/CORS blocked request. Check endpoint origin and CORS headers.'
          : `Sync failed: ${error.message}`;
        lastFetchError = msg;
        showBanner(msg);
        updateStatus();
      } finally {
        syncButton.disabled = false;
      }
    }

    function tickCountdowns() {
      document.querySelectorAll('.countdown').forEach((node) => {
        node.textContent = formatCountdown(node.dataset.reset);
      });
      updateStatus();
    }

    syncButton.addEventListener('click', triggerSync);

    (async function init() {
      await fetchConfig();
      await fetchHistory();
      await fetchData();
      setInterval(async () => {
        await fetchHistory();
        await fetchData();
      }, REFRESH_MS);
      setInterval(tickCountdowns, 1000);
    })();
  </script>
</body>
</html>
