<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Quota Mission Control</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;800&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg-deep: #050506;
      --bg-panel: #0f1012;
      --border-metal: #1a2a26;
      --text-main: #e0e0e0;
      --text-dim: #7a7f84;
      --ok: #4fb7a0;
      --warn: #ffb700;
      --bad: #ff3e3e;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at 50% 10%, #10201c 0%, #050506 55%);
      color: var(--text-main);
      font-family: Outfit, sans-serif;
    }
    header {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: space-between;
      align-items: center;
      padding: 18px 24px;
      border-bottom: 1px solid var(--border-metal);
      background: rgba(10, 13, 14, 0.92);
    }
    .title { font-size: 1.15rem; font-weight: 800; letter-spacing: 2px; text-transform: uppercase; }
    .controls { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    button {
      border: none;
      border-radius: 8px;
      padding: 9px 14px;
      font-weight: 700;
      background: var(--ok);
      color: #04261f;
      cursor: pointer;
      pointer-events: auto;
      position: relative;
      z-index: 2;
      transition: transform 120ms ease;
    }
    button:active { transform: translateY(1px); }
    button[disabled] { opacity: .6; cursor: progress; }
    .pill {
      border: 1px solid var(--border-metal);
      background: rgba(0,0,0,.25);
      border-radius: 999px;
      padding: 7px 12px;
      font-size: .75rem;
      font-family: "JetBrains Mono", monospace;
    }
    .status-ok { color: var(--ok); }
    .status-stale { color: var(--warn); }
    .status-error { color: var(--bad); }
    #banner {
      display: none;
      margin: 12px 24px 0;
      border: 1px solid rgba(255,62,62,.4);
      border-radius: 8px;
      padding: 10px 12px;
      color: #ffd5d5;
      background: rgba(255,62,62,.14);
      font-size: .9rem;
    }
    #error-panel {
      margin: 12px 24px;
      border: 1px solid var(--border-metal);
      border-radius: 10px;
      background: rgba(8,10,11,.75);
      padding: 14px;
      font-size: .9rem;
      line-height: 1.4;
    }
    #error-panel h2 { margin: 0 0 8px; font-size: 1rem; }
    #error-panel ul { margin: 8px 0 0 18px; color: var(--text-dim); }
    #action-status {
      margin-top: 8px;
      font-size: .85rem;
      color: var(--text-dim);
    }
    main {
      padding: 24px;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 16px;
    }
    .card {
      border: 1px solid var(--border-metal);
      border-radius: 12px;
      background: var(--bg-panel);
      padding: 16px;
    }
    .top { display: flex; justify-content: space-between; gap: 10px; }
    .provider { font-size: .8rem; color: var(--text-dim); text-transform: uppercase; letter-spacing: 1px; }
    .label { font-size: 1.1rem; font-weight: 700; margin-top: 3px; }
    .percent { font-family: "JetBrains Mono", monospace; font-size: 1.1rem; font-weight: 700; }
    .bar { height: 10px; border-radius: 999px; overflow: hidden; background: #1a1c1f; margin: 12px 0; }
    .fill { height: 100%; }
    .meta { display: grid; gap: 6px; font-size: .82rem; color: var(--text-dim); }
    .sparkline { width: 60px; height: 18px; }
    .empty {
      margin: 24px;
      border: 1px dashed var(--border-metal);
      padding: 24px;
      border-radius: 12px;
      text-align: center;
      color: var(--text-dim);
    }
  </style>
</head>
<body>
  <header>
    <div class="title">Quota Core</div>
    <div class="controls">
      <button id="sync-button" type="button">SYNC NOW</button>
      <div class="pill">Status: <span id="status-text" class="status-stale">STALE</span></div>
      <div class="pill" id="last-sync">Last good data: --</div>
    </div>
  </header>

  <div id="banner"></div>

  <section id="error-panel">
    <h2>Data Health</h2>
    <div>Last fetch error: <span id="last-error">None</span></div>
    <div>Last good data time: <span id="last-good-time">--</span></div>
    <div>Action status: <span id="action-status">Idle</span></div>
    <ul>
      <li>Usage can jump or drop at reset boundaries.</li>
      <li>If status is STALE/ERROR, verify scanner scheduling and OpenClaw credentials.</li>
      <li>Cross-origin sync endpoints may fail due to CORS; configure same-origin proxy when possible.</li>
    </ul>
  </section>

  <main id="dashboard-grid"></main>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const REFRESH_MS = 30000;
      const STALE_MS = 120000;
      const cacheKey = 'quota_cache_v2';

      let dashboardData = null;
      let historyData = {};
      let config = { syncEndpoint: null, syncMethod: 'POST', syncPayload: {}, refreshDelayMs: 3000 };
      let lastFetchSuccessAt = 0;
      let lastFetchError = null;
      let activeFetchController = null;
      let activeFetchPromise = null;

      const grid = document.getElementById('dashboard-grid');
      const syncButton = document.getElementById('sync-button');
      const statusText = document.getElementById('status-text');
      const lastSyncText = document.getElementById('last-sync');
      const lastErrorText = document.getElementById('last-error');
      const lastGoodTimeText = document.getElementById('last-good-time');
      const actionStatusText = document.getElementById('action-status');
      const banner = document.getElementById('banner');

      const required = { grid, statusText, lastSyncText, lastErrorText, lastGoodTimeText, banner, actionStatusText };
      const missingCore = Object.entries(required).filter(([, node]) => !node).map(([name]) => name);
      if (missingCore.length) {
        console.error('Critical dashboard DOM nodes missing:', missingCore.join(', '));
        return;
      }

      if (!syncButton) {
        const message = 'Refresh control missing from DOM';
        console.error(message);
        banner.textContent = message;
        banner.style.display = 'block';
        actionStatusText.textContent = message;
        actionStatusText.className = 'status-error';
        return;
      }

      const getCachedData = () => {
        try {
          return localStorage.getItem(cacheKey);
        } catch (error) {
          console.warn('Local cache unavailable:', error);
          return null;
        }
      };

      const setCachedData = (value) => {
        try {
          localStorage.setItem(cacheKey, value);
        } catch (error) {
          console.warn('Unable to write cache:', error);
        }
      };

      const showBanner = (message) => {
        banner.textContent = message;
        banner.style.display = 'block';
        clearTimeout(showBanner._timer);
        showBanner._timer = setTimeout(() => banner.style.display = 'none', 7000);
      };

      const setActionStatus = (message, level = 'status-ok') => {
        actionStatusText.textContent = message;
        actionStatusText.className = level;
        if (level === 'status-error') {
          console.error('[dashboard]', message);
        } else {
          console.info('[dashboard]', message);
        }
      };

      const localDate = (iso) => {
      const date = new Date(iso);
      if (isNaN(date.getTime())) return '--';
      return date.toLocaleString();
    };

      function classifyColor(percent) {
      if (percent < 50) return 'var(--ok)';
      if (percent < 80) return 'var(--warn)';
      return 'var(--bad)';
    }

      function formatCountdown(resetAt) {
      if (!resetAt) return 'No reset timestamp';
      const diff = Number(resetAt) - Date.now();
      if (diff <= 0) return 'Reset window reached';
      const h = Math.floor(diff / 3600000);
      const m = Math.floor((diff % 3600000) / 60000);
      const s = Math.floor((diff % 60000) / 1000);
      return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
    }

      function renderSparkline(series) {
      const points = (series || []).slice(-20);
      if (!points.length) {
        return '<svg class="sparkline" viewBox="0 0 60 18" aria-label="No trend"><line x1="0" y1="17" x2="60" y2="17" stroke="#444"/></svg>';
      }
      const coords = points.map((item, i) => {
        const x = points.length === 1 ? 0 : (i / (points.length - 1)) * 60;
        const y = 18 - (Math.max(0, Math.min(100, Number(item.percentage) || 0)) / 100) * 18;
        return `${x.toFixed(1)},${y.toFixed(1)}`;
      }).join(' ');
      return `<svg class="sparkline" viewBox="0 0 60 18" aria-label="Trend"><polyline fill="none" stroke="var(--ok)" stroke-width="1.6" points="${coords}"/></svg>`;
    }

      function updateStatus() {
      const now = Date.now();
      let status = 'OK';
      let cls = 'status-ok';

      if (!dashboardData && !getCachedData()) {
        status = 'ERROR';
        cls = 'status-error';
      } else {
        const sourceTs = dashboardData?.lastUpdated ? Date.parse(dashboardData.lastUpdated) : NaN;
        const ageFromSource = Number.isFinite(sourceTs) ? now - sourceTs : Infinity;
        const ageFromFetch = lastFetchSuccessAt ? now - lastFetchSuccessAt : Infinity;
        if (ageFromSource > STALE_MS || ageFromFetch > STALE_MS) {
          status = 'STALE';
          cls = 'status-stale';
        }
      }

      statusText.textContent = status;
      statusText.className = cls;

      const goodTime = dashboardData?.lastUpdated || (lastFetchSuccessAt ? new Date(lastFetchSuccessAt).toISOString() : null);
      const local = goodTime ? localDate(goodTime) : '--';
      lastSyncText.textContent = `Last good data: ${local}`;
      lastSyncText.title = goodTime || '';
      lastGoodTimeText.textContent = local;
      lastGoodTimeText.title = goodTime || '';
      lastErrorText.textContent = lastFetchError || 'None';
    }

      function renderModels() {
      const models = dashboardData?.models || [];
      if (!models.length) {
        grid.innerHTML = '<div class="empty">No usage windows found (check credentials).</div>';
        return;
      }

      grid.innerHTML = models.map((model) => {
        const pct = Math.max(0, Math.min(100, Number(model.percentage) || 0));
        const color = classifyColor(pct);
        const trend = renderSparkline(historyData[model.key]);
        const resetIso = model.resetAtIso || (model.resetAt ? new Date(model.resetAt).toISOString() : '');
        return `
          <article class="card">
            <div class="top">
              <div>
                <div class="provider">${model.provider || 'Unknown provider'}</div>
                <div class="label">${model.label || model.key}</div>
              </div>
              <div class="percent" style="color:${color}">${pct.toFixed(2)}%</div>
            </div>
            <div class="bar"><div class="fill" style="width:${pct}%;background:${color}"></div></div>
            <div class="meta">
              <div>Reset in: <span class="countdown" data-reset="${model.resetAt || ''}">${formatCountdown(model.resetAt)}</span></div>
              <div title="${resetIso || ''}">Reset at: ${resetIso ? localDate(resetIso) : '--'}</div>
              <div>Key: ${model.key}</div>
              <div>Trend: ${trend}</div>
            </div>
          </article>
        `;
      }).join('');
    }

      async function fetchConfig() {
        try {
          const res = await fetch('config.json', { cache: 'no-store' });
          if (!res.ok) return;
          config = { ...config, ...(await res.json()) };
        } catch (_) {
          // optional config fallback
        }
        syncButton.textContent = config.syncEndpoint ? 'SYNC NOW' : 'REFRESH';
      }

      async function fetchHistory() {
      try {
        const v = Math.floor(Date.now() / 30000);
        const res = await fetch(`history.json?v=${v}`, { cache: 'no-store' });
        if (!res.ok) return;
        historyData = await res.json();
      } catch (_) {
        historyData = {};
      }
    }

      async function fetchData({ force = false } = {}) {
        if (activeFetchPromise) {
          if (!force) {
            setActionStatus('Fetch already in progress; skipped duplicate refresh.', 'status-stale');
            return activeFetchPromise;
          }
          console.warn('[dashboard] Aborting previous fetch for forced refresh.');
          activeFetchController?.abort();
        }

        const controller = new AbortController();
        activeFetchController = controller;
        const timeoutId = setTimeout(() => controller.abort(), 5000);
        let requestPromise;

        requestPromise = (async () => {
          try {
            const v = Math.floor(Date.now() / 30000);
            const res = await fetch(`data.json?v=${v}`, { cache: 'no-store', signal: controller.signal });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const text = await res.text();
            dashboardData = JSON.parse(text);
            setCachedData(text);
            lastFetchSuccessAt = Date.now();
            lastFetchError = null;
            setActionStatus('Data refreshed successfully.', 'status-ok');
          } catch (error) {
            lastFetchError = error.name === 'AbortError' ? 'Request timed out' : (error.message || String(error));
            const cached = getCachedData();
            if (cached) {
              dashboardData = JSON.parse(cached);
              showBanner(`Fetch failed (using cache): ${lastFetchError}`);
              setActionStatus('Fetch failed (using cache).', 'status-stale');
            } else {
              dashboardData = null;
              showBanner(`Fetch failed (no cache available): ${lastFetchError}`);
              setActionStatus('Fetch failed (no cache available).', 'status-error');
            }
          } finally {
            clearTimeout(timeoutId);
            if (activeFetchController === controller) activeFetchController = null;
            if (activeFetchPromise === requestPromise) activeFetchPromise = null;
            renderModels();
            updateStatus();
          }
        })();

        activeFetchPromise = requestPromise;
        return requestPromise;
      }

      const wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

      async function runRemoteSync() {
        const response = await fetch(config.syncEndpoint, {
          method: config.syncMethod || 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(config.syncPayload || {})
        });
        if (!response.ok) {
          throw new Error(`Sync endpoint returned HTTP ${response.status}`);
        }
      }

      async function handleRefreshClick(event) {
        event.preventDefault();

        const idleLabel = config.syncEndpoint ? 'SYNC NOW' : 'REFRESH';
        const busyLabel = config.syncEndpoint ? 'SYNCING…' : 'REFRESHING…';
        syncButton.disabled = true;
        syncButton.textContent = busyLabel;

        try {
          if (config.syncEndpoint) {
            setActionStatus('Running remote sync…', 'status-stale');
            try {
              await runRemoteSync();
              setActionStatus('Remote sync completed. Refreshing dashboard…', 'status-stale');
              await wait(Number(config.refreshDelayMs) || 3000);
            } catch (error) {
              const msg = error instanceof TypeError
                ? 'Sync endpoint blocked by CORS. Refresh still works. Configure a same-origin endpoint or proxy.'
                : `Sync failed: ${error.message || String(error)}`;
              lastFetchError = msg;
              showBanner(msg);
              setActionStatus(msg, 'status-error');
            }
          } else {
            setActionStatus('Refreshing local data…', 'status-stale');
          }

          await fetchHistory();
          await fetchData({ force: true });
        } finally {
          syncButton.disabled = false;
          syncButton.textContent = idleLabel;
        }
      }

      function tickCountdowns() {
      document.querySelectorAll('.countdown').forEach((node) => {
        node.textContent = formatCountdown(node.dataset.reset);
      });
      updateStatus();
    }

      syncButton.addEventListener('click', handleRefreshClick);

      (async function init() {
        await fetchConfig();
        setActionStatus('Dashboard initialized.', 'status-ok');
        await fetchHistory();
        await fetchData({ force: true });
        setInterval(async () => {
          await fetchHistory();
          await fetchData();
        }, REFRESH_MS);
        setInterval(tickCountdowns, 1000);
      })();
    });
  </script>
</body>
</html>
